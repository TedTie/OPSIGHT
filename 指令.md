# 指令：OPSIGHT 身份认证与权限解析深度诊断 (P0-Critical)

**诊断目标**: 验证系统从用户登录、JWT Token生成、Token解析到最终 `current_user` 对象生成的整个链路是否正确、完整地处理了用户的身份信息（特别是角色、用户组ID、身份类型）。

**核心怀疑**: 列表可见性问题可能并非由API端的过滤逻辑单独引起，而是源于上游的身份验证服务未能正确加载或传递用户的完整权限属性，导致下游的过滤逻辑收到了不完整或错误的用户数据。

---

## 1. 诊断步骤 (Diagnostic Steps)

请严格按照以下步骤执行，并详细记录每一步的输出。这将为最终的根因分析提供决定性证据。

### **步骤 1.1: 验证登录接口 (`/auth/login`) 的 Token 生成逻辑**

**目的**: 确认在生成 JWT Token 时，是否已将用户的关键信息（`id`, `role`, `group_id`, `identity_type`）正确地编码进了 Token 的 `payload` 中。

1.  **定位代码**: 打开文件 `backend/app/api/deps.py` (或其他处理认证的文件)，找到负责创建 JWT Token 的函数，通常名为 `create_access_token`。
2.  **添加临时调试代码**: 在 `return encoded_jwt` 之前，加入一行 `print()` 语句，以明文方式打印即将被编码的 `data` (payload)。

    ```python
    # 示例位置：在 create_access_token 函数内部
    def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
        to_encode = data.copy()
        # ... (expires_delta 逻辑)
        
        # --- 临时调试代码 ---
        print(f"[DEBUG-JWT-PAYLOAD]: {to_encode}") 
        # --- 结束调试 ---
        
        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
        return encoded_jwt
    ```
3.  **重启服务并模拟登录**:
    *   重启后端服务以加载修改后的代码。
    *   使用 Postman 或 cURL，依次对以下三个用户发起登录请求 (`POST /api/v1/auth/login`)：
        *   `admin`
        *   `jlpss-chenjianxiong`
        *   `test_user`
4.  **记录控制台输出**: 观察后端服务的控制台，记录每次登录时打印出的 `[DEBUG-JWT-PAYLOAD]` 内容。

### **步骤 1.2: 验证用户身份获取接口 (`/auth/me`) 的数据来源**

**目的**: 确认 `get_current_active_user` 这个依赖函数是否能从 Token 中正确解码出所有用户信息，并从数据库中查询到完整的、最新的 `User` 对象。

1.  **定位代码**: 打开文件 `backend/app/api/deps.py`，找到核心依赖函数 `get_current_active_user`。
2.  **添加临时调试代码**: 在此函数的 `return user` 语句之前，加入 `print()` 语句，打印从 Token 解码出的用户名和从数据库查询到的完整 `user` 对象信息。

    ```python
    # 示例位置：在 get_current_active_user 函数内部
    async def get_current_active_user(
        token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)
    ):
        # ... (try...except 块处理 token 解码)
        username: str = payload.get("sub")
        # ...

        user = db.query(User).filter(User.username == username).first()
        if user is None:
            # ... (抛出异常)

        # --- 临时调试代码 ---
        print(f"[DEBUG-USER-OBJECT]: Decoded Username='{username}', DB User Object: id={user.id}, username='{user.username}', role='{user.role}', group_id={user.group_id}, identity_type='{user.identity_type}'")
        # --- 结束调试 ---

        return user
    ```
3.  **重启服务并调用受保护接口**:
    *   重启后端服务以加载修改后的代码。
    *   使用 Postman 或 cURL，携带**上一步中获取的各个用户的 JWT Token**，依次调用 `/api/v1/tasks` 接口。
4.  **记录控制台输出**: 观察后端服务的控制台，记录每次调用时打印出的 `[DEBUG-USER-OBJECT]` 内容。

## 2. 诊断报告模板 (Diagnostic Report Template)

在完成以上所有步骤后，请根据记录的输出，填写并提交以下诊断报告。

```plaintext
## OPSIGHT 身份认证与权限解析诊断报告

**诊断时间**: (填写当前时间)
**诊断执行人**: Trae AI

---

### **Part 1: JWT Payload 生成验证**

- **用户 `admin` 的 Payload**:
`[DEBUG-JWT-PAYLOAD]: { ... }` (在此粘贴实际输出)
**分析**: (例如：关键字段 `sub`, `role`, `gid`, `idt` 是否存在且值正确?)

- **用户 `jlpss-chenjianxiong` 的 Payload**:
`[DEBUG-JWT-PAYLOAD]: { ... }` (在此粘贴实际输出)
**分析**: (例如：`gid` 是否为 `1`?)

- **用户 `test_user` 的 Payload**:
`[DEBUG-JWT-PAYLOAD]: { ... }` (在此粘贴实际输出)
**分析**: (例如：`role` 是否为 `user`, `gid` 是否为 `1`?)

### **Part 2: `current_user` 对象生成验证**

- **当使用 `admin` Token 调用接口时**:
`[DEBUG-USER-OBJECT]: ...` (在此粘贴实际输出)
**分析**: (例如：从数据库读取的 `group_id` 和 `identity_type` 是否与预期一致?)

- **当使用 `jlpss-chenjianxiong` Token 调用接口时**:
`[DEBUG-USER-OBJECT]: ...` (在此粘贴实际输出)
**分析**: (例如：`role` 是否为 `admin`?)

- **当使用 `test_user` Token 调用接口时**:
`[DEBUG-USER-OBJECT]: ...` (在此粘贴实际输出)
**分析**: (例如：`group_id` 是否为 `1`, 并且不为 `None`?)

---

### **初步结论 (Initial Findings)**

- [ ] **A. 链路正常**: JWT Payload 和 `current_user` 对象均包含完整且正确的权限信息。问题确实出在下游的 API 过滤逻辑上。
- [ ] **B. JWT Payload 缺陷**: 在登录时，关键信息（如 `group_id`）没有被加入到 JWT 的 Payload 中。
- [ ] **C. `current_user` 解析缺陷**: Token 中有信息，但在 `get_current_active_user` 中未能正确从数据库加载完整的 `User` 对象，导致 `current_user` 对象信息不全。
- [ ] **D. 其他发现**: (描述任何其他异常情况)
```

---

Trae，请立即执行此诊断指令。你的首要任务不是修复，而是**侦查和取证**。这份报告的结果将直接决定我们下一步的行动方向。
